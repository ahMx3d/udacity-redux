<!DOCTYPE html>
<html>

<head>
	<title>Native Redux App</title>
	<link rel="icon" href="data:;base64,iVBORw0KGgo=" />
	<meta charset="UTF-8" />
	<style>
		.app {
			display: flex;
			flex-wrap: wrap;
			justify-content: space-around;
			align-items: baseline;
		}
	</style>
</head>

<body>
	<div class="app">
		<div>
			<h1>Todos List</h1>
			<input type="text" placeholder="New Todo" id="todo" />
			<button id="todo-btn">Add</button>
			<ul id="todos"></ul>
		</div>
		<div>
			<h1>Goals List</h1>
			<input type="text" placeholder="New Goal" id="goal" />
			<button id="goal-btn">Add</button>
			<ul id="goals"></ul>
		</div>
	</div>

	<hr />
	<div class="app" id="app"></div>

	<!-- Redux -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
	<!-- React -->
	<script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js" crossorigin></script>
	<!-- React DOM -->
	<script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js" crossorigin></script>
	<!-- Babel -->
	<script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js" crossorigin></script>
	<!-- API -->
	<script src="https://tylermcginnis.com/goals-todos-api/index.js"></script>
	<!-- Redux Thunk -->
	<script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script>

	<script type="module" src="src/index.js"></script>

	<script type="text/javascript">

		const generateId = () => Math.random().toString(36).substring(2) + new Date().getTime().toString(36);

		const ADD_TODO = 'ADD_TODO',
			REMOVE_TODO = 'REMOVE_TODO',
			TOGGLE_TODO = 'TOGGLE_TODO',
			ADD_GOAL = 'ADD_GOAL',
			RECEIVE_DATA = 'RECEIVE_DATA',
			REMOVE_GOAL = 'REMOVE_GOAL';

		// thunkifiable Action Creators

		const handleInitialData = () => {
			return (dispatch) => {

				// Fetch Data From Remote API
				return Promise.all([
					API.fetchTodos(),
					API.fetchGoals(),
				]).then(([todos, goals]) => {
					// console.log('todos', todos);
					// console.log('goals', goals);
					dispatch(receiveData(todos, goals))
				})
			}
		}

		const handleRemoveGoal = (goal) => {
			return (dispatch) => {
				dispatch(removeGoal(goal.id))
				return API.deleteGoal(goal.id)
					.catch(() => {
						dispatch(addGoal(goal))
						alert('An Error Occurred, Try Again Later')
					})
			}
		}
		const handleAddGoal = (name, closure) => {
			return (dispatch) => {
				return API.saveGoal(name)
					.then((goal) => {
						dispatch(addGoal(goal))
						closure()
					})
					.catch(() => alert('An Error Occurred, Try Again Later'))
			}
		}

		const handleAddTodo = (name, closure) => {
			return (dispatch) => {
				return API.saveTodo(name)
					.then((todo) => {
						dispatch(addTodo(todo))
						closure()
					})
					.catch(() => alert('An Error Occurred, Try Again Later'))
			}
		}
		const handleDeleteTodo = (todo) => {
			return (dispatch) => {
				dispatch(removeTodo(todo.id))
				return API.deleteTodo(todo.id)
					.catch(() => {
						dispatch(addTodo(todo))
						alert('An Error Occurred, Try Again Later')
					})
			}
		}
		const handleToggleTodo = (id) => {
			return (dispatch) => {
				dispatch(toggleTodo(id))
				return API.saveTodoToggle(id)
					.catch(() => {
						dispatch(toggleTodo(id))
						alert('An Error Occurred, Try Again Later')
					})
			}
		}

		// Action Creators
		const receiveData = (todos, goals) => ({
			type: RECEIVE_DATA,
			todos,
			goals,
		});
		const addTodo = (todo) => ({
			type: ADD_TODO,
			todo
		});
		const removeTodo = (id) => ({
			type: REMOVE_TODO,
			id
		});
		const toggleTodo = (id) => ({
			type: TOGGLE_TODO,
			id
		});

		const addGoal = (goal) => ({
			type: ADD_GOAL,
			goal
		});
		const removeGoal = (id) => ({
			type: REMOVE_GOAL,
			id
		});

		// Todos Reducer Function
		const todos = (state = [], action) => {
			switch (action.type) {
				case ADD_TODO:
					return state.concat([action.todo]);
				case REMOVE_TODO:
					return state.filter((todo) => todo.id !== action.id);
				case TOGGLE_TODO:
					return state.map(
						(todo) => (todo.id !== action.id ? todo : Object.assign({}, todo, { complete: !todo.complete }))
					);
				case RECEIVE_DATA:
					return action.todos;
				default:
					return state;
			}
		};

		// Goals Reducer Function
		const goals = (state = [], action) => {
			switch (action.type) {
				case RECEIVE_DATA:
					return action.goals;
				case ADD_GOAL:
					return state.concat([action.goal]);
				case REMOVE_GOAL:
					return state.filter((goal) => goal.id !== action.id);
				default:
					return state;
			}
		};

		// Loading Reducer Function
		const loading = (state = true, action) => {
			switch (action.type) {
				case RECEIVE_DATA:
					return false;
				default:
					return state;
			}
		}

		// Middlewares
		const checker = (store) => (next) => (action) => {
			if (action.type === ADD_TODO && action.todo.name.toLowerCase().includes('bitcoin')) {
				return alert("Nope, That's a bad idea");
			}
			if (action.type === ADD_GOAL && action.goal.name.toLowerCase().includes('bitcoin')) {
				return alert("Nope, That's a bad idea");
			}
			return next(action);
		};

		const logger = (store) => (next) => (action) => {
			console.group(action.type);
			console.log('Action: ', action);
			// Hits dispatch in case there is no middleware after the current one
			const result = next(action);
			console.log('New State: ', store.getState());
			console.groupEnd();
			return result;
		};

		// Redux Thunk Applied Manually
		// const thunk = (store) => (next) => (action) => {
		// 	if (typeof action === 'function') {
		// 		return action(store.dispatch)
		// 	}
		// 	return next(action)
		// }

		const store = Redux.createStore(
			Redux.combineReducers({
				todos,
				goals,
				loading,
			}),
			Redux.applyMiddleware(ReduxThunk.default, checker, logger)
		);
	</script>
	<script type="text/babel">
		class Todos extends React.Component {
			addItem = (e) => {
				e.preventDefault();

				this.props.dispatch(handleAddTodo(
					this.input.value,
					() => this.input.value = ''
				))
			};
			removeItem = (todo) => {
				this.props.dispatch(handleDeleteTodo(todo))
			}
			toggleItem = (todo) => {
				this.props.dispatch(handleToggleTodo(todo.id))
			}

			render() {
				return (
					<div>
						<h2>Todos List</h2>
						<input type="text" placeholder="Add Todo" ref={(input) => (this.input = input)} />
						<button onClick={this.addItem}>Add Todo</button>
						<List toggle={this.toggleItem} remove={this.removeItem} items={this.props.todos} />
					</div>
				);
			}
		}
		class Goals extends React.Component {
			addItem = (e) => {
				e.preventDefault()

				this.props.dispatch(handleAddGoal(
					this.input.value,
					() => this.input.value = ''
				))
			}

			removeItem = (goal) => {
				this.props.dispatch(handleRemoveGoal(goal))
			}

			render() {
				return (
					<div>
						<h2>Goals List</h2>
						<input type="text" placeholder="Add Goal" ref={(input) => (this.input = input)} />
						<button onClick={this.addItem}>Add Goal</button>
						<List remove={this.removeItem} items={this.props.goals} />
					</div>
				);
			}
		}

		const List = (props) => {
			return (
				<ul>
					{props.items.map(item => (
						<li key={item.id}>
							<span style={{ textDecoration: item.complete ? 'line-through' : 'none' }} onClick={() => props.toggle && props.toggle(item)}>{item.name}</span>
							<button onClick={() => props.remove(item)}>X</button>
						</li>
					))}
				</ul>
			);
		};

		const ConnectedTodos = connect((state) => ({
			todos: state.todos
		}))(Todos)

		const ConnectedGoals = connect((state) => ({
			goals: state.goals
		}))(Goals)

		class App extends React.Component {
			componentDidMount() {
				const { dispatch } = this.props;
				dispatch(handleInitialData())
			}
			render() {
				return this.props.loading ? <h3>Loading...</h3> : (
					<React.Fragment>
						<ConnectedTodos />
						<ConnectedGoals />
					</React.Fragment>
				);
			}
		}

		const ConnectedApp = connect((state) => ({
			loading: state.loading
		}))(App)

		const Context = React.createContext()

		function connect(mapStateToProps) {
			return (Component) => {
				class Receiver extends React.Component {
					componentDidMount() {
						const { subscribe } = this.props.store
						this.unsubscribe = subscribe(() => { this.forceUpdate() })
					}
					componentWillUnmount() {
						this.unsubscribe()
					}
					render() {
						const { dispatch, getState } = this.props.store
						const state = getState()
						const stateNeeded = mapStateToProps(state)
						return <Component {...stateNeeded} dispatch={dispatch} />
					}
				}
				class ConnectedComponent extends React.Component {
					render() {
						return (
							<Context.Consumer>
								{(store) => <Receiver store={store} />}
							</Context.Consumer>
						)
					}
				}
				return ConnectedComponent
			}
		}

		class Provider extends React.Component {
			render() {
				return (
					<Context.Provider value={this.props.store}>
						{this.props.children}
					</Context.Provider>
				)
			}
		}

		ReactDOM.render(
			<Provider store={store}>
				<ConnectedApp />
			</Provider>,
			document.getElementById('app'));

	</script>
</body>

</html>